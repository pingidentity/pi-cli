#!/usr/bin/env sh

########################################################################################################################
# This tool is used for several Ping Identity related products including:
#
#   - Managing Ping Identity PingOne environment.
#   - Managing Ping Identity DevOps environment for Docker and Kubernetes.
#
# ------------
# Installation
# ------------
#   brew tap pingidentity/tap
#   brew install pingctl
#
# ------------
# Upgrades
# ------------
#   brew upgrade pingctl
#
# ------------
# Requirements
# ------------
# The script requires the following tools to be installed:
JQ="jq"
BASE64="base64"
OPENSSL="openssl"
CURL="curl -sL "
JWT="jwt"

################################################################################
# Command and Version Info
################################################################################
CMD="pingctl"
VERSION="1.0.5"

################################################################################
# Platform vars
################################################################################
PLATFORM="unknown"
unamestr=$(uname)
[ "${unamestr}" = "Linux" ] && PLATFORM="linux"
# shellcheck disable=SC2034
[ "${unamestr}" = "Darwin" ] && PLATFORM="mac"

################################################################################
# Ping Identity tools & config information
################################################################################
DOT_PINGIDENTITY="${HOME}/.pingidentity"
WORK_DIR="${DOT_PINGIDENTITY}/${CMD}"
PINGONE_ACCESS_TOKEN_FILE="${WORK_DIR}/pingone.token"
test -d "${WORK_DIR}" || mkdir -p "${WORK_DIR}"

################################################################################
# legacy ping-devops config file
################################################################################
PING_DEVOPS_CONFIG="${DOT_PINGIDENTITY}/devops"

################################################################################
# pingctl config environmental variables
################################################################################
DEFAULT_PINGCTL_CONFIG="${DOT_PINGIDENTITY}/config"
PINGCTL_CONFIG="${PINGCTL_CONFIG:-${DEFAULT_PINGCTL_CONFIG}}"
PINGCTL_DEFAULT_OUTPUT="${PINGCTL_DEFAULT_OUTPUT:-table}"

################################################################################
# Kube OIDC Cache Information
################################################################################
KUBE_OIDC_CACHE="${HOME}/.kube/cache/oidc-login"

################################################################################
# Standard variables expected in config file
################################################################################
STANDARD_VARIABLES="
  PING_IDENTITY_DEVOPS_USER
  PING_IDENTITY_DEVOPS_KEY
  PING_IDENTITY_DEVOPS_HOME
  PING_IDENTITY_DEVOPS_REGISTRY
  PING_IDENTITY_DEVOPS_TAG
  PING_IDENTITY_ACCEPT_EULA
  PINGONE_API_URL
  PINGONE_AUTH_URL
  PINGONE_ENVIRONMENT_ID
  PINGONE_WORKER_APP_CLIENT_ID
  PINGONE_WORKER_APP_CLIENT_SECRET
  PINGONE_WORKER_APP_GRANT_TYPE
  PINGONE_WORKER_APP_REDIRECT_URI"

################################################################################
# Check for a .pingidentity directory
################################################################################
test -d "${DOT_PINGIDENTITY}" || mkdir -p "${DOT_PINGIDENTITY}"

################################################################################
# Temporary directory used throughout script and cleaned up at exit
################################################################################
TMP_DIR="$(mktemp -d)"
PINGONE_POST_JSON="${TMP_DIR}/pingone-post.json"
PINGONE_CALL_RESPONSE="${TMP_DIR}/pingone-call-response.json"
PINGONE_API_RESULTS="$TMP_DIR/pingone.api.results.json"
PINGONE_DEBUG="${TMP_DIR}/pingone.debug"
LICENSE_RESPONSE="${TMP_DIR}/product.lic"

################################################################################
# cleanup - Ensures that we cleanup any temporary directories we create upon exit
################################################################################
cleanup() {
    rm -rf "$TMP_DIR"
}

trap cleanup EXIT

################################################################################
# echo_error (message) - prints an Error: message
################################################################################
echo_error() {
    if test ! -z "$*"; then
        printf "=========================================================================\n"
        # redirect with control characters not expanded using %s
        # shellcheck disable=SC2059
        printf "Error: ${1}\n"
        printf "=========================================================================\n"
    fi
}

################################################################################
# check_config_file - Verify that the config_file is found
################################################################################
check_config_file() {
    _pingctl_command="${1}"

    case "${_pingctl_command}" in
        version | clean)
            return
            ;;
    esac

    if test ! -f "${PINGCTL_CONFIG}"; then
        if test -f "${PING_DEVOPS_CONFIG}"; then
            printf "################################################################################\n"
            printf "A pingctl config file '%s' was not found.  Is this the first time running pingctl?\n" "${PINGCTL_CONFIG}"

            #
            # First, try to start from an existing default pingctl config
            if test -f "${DEFAULT_PINGCTL_CONFIG}"; then
                printf "\n"
                printf "  Found a default pingctl config file '%s'\n" "${DEFAULT_PINGCTL_CONFIG}"
                printf "\n"
                printf "  Would you like to seed your config with this? [y] ?\n"
                read -r answer

                if [ "${answer}" = "" ] || [ "${answer}" = "Y" ] || [ "${answer}" = "y" ]; then
                    cp "${DEFAULT_PINGCTL_CONFIG}" "${PINGCTL_CONFIG}"
                fi
            #
            # else, start from an existing ping-devops config
            elif test -f "${PING_DEVOPS_CONFIG}"; then
                printf "\n"
                printf "  Found a default ping-devops config file '%s'\n" "${PING_DEVOPS_CONFIG}"
                printf "\n"
                printf "  Would you like to seed your config with this? [y] ?\n"
                read -r answer

                if [ "${answer}" = "" ] || [ "${answer}" = "Y" ] || [ "${answer}" = "y" ]; then
                    cp "${PING_DEVOPS_CONFIG}" "${PINGCTL_CONFIG}"
                fi
            fi

            if test "${_pingctl_command}" = "config"; then
                printf "\n"
                printf "   continuing with config...\n"
            elif test ! -f "${PINGCTL_CONFIG}"; then
                printf "\n"
                printf "   To continue with '%s' command, configure pingctl first with:\n" "${_pingctl_command}"
                printf "\n"
                printf "      pingctl config\n"
                exit
            fi
            printf "################################################################################\n"
        fi
    fi

    # shellcheck disable=SC1090
    test -f "${PINGCTL_CONFIG}" && . "${PINGCTL_CONFIG}"
}

################################################################################
# check_variables - Verify that certain variables are set
################################################################################
check_variables() {
    for _var in "${@}"; do
        test -z "$(get_value "${_var}")" &&
            printf "Variable is not set: %s\n" "${_var}" &&
            _var_check_fails=true
    done

    test ${_var_check_fails} &&
        printf "\n" &&
        printf "To get more information on these variables:\n" &&
        printf "  https://pingctl.pingidentity.com/\n" &&
        printf "\n" &&
        printf "Set this/these in your config with:\n" &&
        printf "  %s config\n" "${CMD}" &&
        printf "\n" &&
        exit
}

################################################################################
# USAGE_KUBERNETES_DETAIL is used as an indirect argument for usage_command(). Disable shellcheck.
# shellcheck disable=SC2034
USAGE_KUBERNETES_DETAIL="Kubernetes Tools

Usage:
  ${CMD} k8s generate             # Kubernetes Resource Generation Tools
  ${CMD} k8s oidc                 # kubectl/kubelogin OIDC Tools"

################################################################################
USAGE_GENERATE_DETAIL="Kubernetes Resource Generation Tools

Usage:
  ${CMD} k8s generate devops-secret                    # Ping DevOps secret
  ${CMD} k8s generate tls-secret {domain}              # TLS Cert/Key (i.e. example.com)
  ${CMD} k8s generate ssh-id-secret {ssh id_rsa file}  # SSH ID Key (i.e. ~/.ssh/id_rsa)
  ${CMD} k8s generate license-secret {license file}    # License secret from license file
  ${CMD} k8s generate license-secret {product} {ver}   # License secret for product/ver"

################################################################################
# USAGE_LICENSE_DETAIL is used as an indirect argument for usage_command(). Disable shellcheck.
# shellcheck disable=SC2034
USAGE_LICENSE_DETAIL="Ping Identity Licensing Tools

Usage:
  ${CMD} license {product} {ver}          # Obtain an evaluation license file for product/ver

Examples:
  ${CMD} license pingfederate 11.1"

################################################################################
# USAGE_OIDC_DETAIL is used as an indirect argument for usage_command(). Disable shellcheck.
# shellcheck disable=SC2034
USAGE_OIDC_DETAIL="kubectl/kubelogin OIDC Tools

Usage:
  ${CMD} k8s oidc clear                                # Remove ~/.kube/cache/oidc-login
  ${CMD} k8s oidc {claim}                              # Get oidc claim (i.e. email, groups)
  ${CMD} k8s oidc info                                 # Display jwt"

################################################################################
USAGE_PINGONE_DETAIL="Manage PingOne Environments

Usage:
  ${CMD} pingone get                  # Get PingOne resource(s)
  ${CMD} pingone add                  # Add PingOne resource
  ${CMD} pingone delete               # Delete PingOne resource

  ${CMD} pingone add-user-group       # Add group to user
  ${CMD} pingone delete-user-group    # Delete group from user

  ${CMD} pingone token                # Obtain access token"

################################################################################
OPTIONS_R="  -r
     Provide REST Calls"

################################################################################
OPTIONS_P="  -p {population name}
     Population to add user/group into.
     If not provided 'Default' population used"

################################################################################
# USAGE_PINGONE_GET_DETAIL is used as an indirect argument for usage_command() via USAGE_CONTEXT. Disable shellcheck.
# shellcheck disable=SC2034
USAGE_PINGONE_GET_DETAIL="Get PingOne Objects

Usage:
  ${CMD} pingone get groups
  ${CMD} pingone get populations
  ${CMD} pingone get users

Options:
  -o [ table | csv | json ]
     Output format (default: table)
     also set with env variable: PINGCTL_DEFAULT_OUTPUT

  -i {id}
     Search based on object guid

  -n {name}
     Search based on exact filter

  -f {filter}
     PingOne filter (SCIM based)
        ex: '.name.given eq \"john\"'
            '.email sw \"john\"'

  -c {columns}
     Columns to output based on \"heading:jsonAttr\"
     An example of available jsonAttrs can be found by using a json output first.
        ex: 'LastName:name.family,FirstName:name.given'

  -s {sort column}
     Columns to sort output on based on \"jsonAttr\"
     The jsonAttr MUST be listed in the list of columns (-c option).
        ex: 'name.family'

${OPTIONS_P}

${OPTIONS_R}

Examples:
  ${CMD} pingone get users -i 5c07e067-3eeb-40bb-924b-a419d01ee28f
  ${CMD} pingone get users -n johnsmith@example.com
  ${CMD} pingone get users -f 'name.given eq \"john\"'
  ${CMD} pingone get users -f 'email sw \"john\"'
  ${CMD} pingone get users -c \"LastName:name.family,FirstName:name.given\" -s name.family"

################################################################################
# USAGE_PINGONE_ADD_DETAIL is used as an indirect argument for usage_command() via USAGE_CONTEXT. Disable shellcheck.
# shellcheck disable=SC2034
USAGE_PINGONE_ADD_DETAIL="Add PingOne Objects

Usage:
  ${CMD} pingone add group {group name}

  ${CMD} pingone add population {population name}

  ${CMD} pingone add user {username} {first} {last} [email]
     * REQUIRED: username, first last
       OPTIONAL: email (same as username if not provided)

${OPTIONS_P}

${OPTIONS_R}

Examples:
  ${CMD} pingone add group test-group-name
  ${CMD} pingone add user john@example.com John Smith -p test-population"

################################################################################
# USAGE_PINGONE_DELETE_DETAIL is used as an indirect argument for usage_command() via USAGE_CONTEXT. Disable shellcheck.
# shellcheck disable=SC2034
USAGE_PINGONE_DELETE_DETAIL="Delete PingOne Objects

Usage:
  ${CMD} pingone delete group       {name}
  ${CMD} pingone delete population  {name}
  ${CMD} pingone delete user        {name}

Options:
${OPTIONS_R}"

################################################################################
# USAGE_PINGONE_ADD_USER_GROUP_DETAIL is used as an indirect argument for usage_command(). Disable shellcheck.
# shellcheck disable=SC2034
USAGE_PINGONE_ADD_USER_GROUP_DETAIL="Add PingOne Group to User

Usage:
  ${CMD} pingone add-user-group {username} {groupname}  # Add group to user

Options:
${OPTIONS_R}"

################################################################################
# USAGE_PINGONE_TOKEN_DETAIL is used as an indirect argument for usage_command(). Disable shellcheck.
# shellcheck disable=SC2034
USAGE_PINGONE_TOKEN_DETAIL="kubectl/kubelogin OIDC Tools

Usage:
  ${CMD} pingone token clear         # Remove ${PINGONE_ACCESS_TOKEN_FILE}
  ${CMD} pingone token info          # Display access_token"

################################################################################
# USAGE_PINGONE_DELETE_USER_GROUP_DETAIL is used as an indirect argument for usage_command(). Disable shellcheck.
# shellcheck disable=SC2034
USAGE_PINGONE_DELETE_USER_GROUP_DETAIL="Delete PingOne Group from User
  ${CMD} pingone delete-user-group {username} {groupname}  # Delete group from user

Options:
${OPTIONS_R}"

################################################################################
# usage - Print any message sent as an error and then the usage information
################################################################################
usage() {
    echo_error "$*"
    # using HEREDOC for longer objects
    cat << CMD_USAGE
${CMD} is a CLI from Ping Identity to manage PingOne and other Ping Identity projects/tools.

Usage:
  ${CMD} [command] [options]

Available Commands:
  info               Print ${CMD} config
  config             Manage ${CMD} config
  version            Version Details and Check
  clean              Remove ~/.pingidentity/${CMD}

  kubernetes | k8s   Kubernetes Tools
  license    | lic   Ping Identity Licensing Tools
  pingone    | p1    PingOne Tools

Options:
  -h              Help for ${CMD}

Further help:
  https://pingidentity.github.io/pingctl
CMD_USAGE

    exit
}

################################################################################
# usage_command - print usage info for a specific command
################################################################################
usage_command() {
    _usageCmd="${1}" && shift

    test -z "${_usageCmd}" && _usageCmd="${USAGE_CONTEXT}"
    test -z "${_usageCmd}" && usage

    echo_error "${*}"

    get_value "${_usageCmd}"

    printf "\n"
    exit
    case "${_usageCmd}" in
        pingone)
            printf "%s\n" "${USAGE_PINGONE_DETAIL}"
            ;;
        pingone-get)
            get_value "${_usageCmd}"
            ;;
        generate)
            printf "%s\n" "${USAGE_GENERATE_DETAIL}"
            ;;
        *)
            usage
            ;;
    esac

    printf "\n"
    exit
}

################################################################################
# check_for_tool (tool_name)
#
# Using command function, validate that the tool_name is found
# Any non-zero return code indicates a problem
################################################################################
check_for_tool() {
    _tool="${1}"
    command -v "${_tool}" 2> /dev/null > /dev/null

    test $? -ne 0 && echo_error "'${_tool}' not found, but required to perform function. Please install to continue." && exit
}

################################################################################
# get_value (variable)
#
# Get the value of a variable, preserving the spaces
################################################################################
get_value() {
    if test ! -z "${1}"; then
        IFS="%%"
        eval printf '%s' "\${${1}}"
        unset IFS
    fi
}

################################################################################
# source_config ()
#
# Ensure that we source the CONFIG_FILE
################################################################################
source_config() {
    BASH_PROFILE="${HOME}/.bash_profile"
    ZSHRC="${HOME}/.zshrc"
    DEF_PROFILE="${HOME}/.profile"

    #if test "${?}" = "1"; then
    case "${SHELL}" in
        *bash)
            grep "${PINGCTL_CONFIG}" "${BASH_PROFILE}" > /dev/null
            if test "${?}" = "1"; then
                printf "
################################################################################
# Checking your bash profile
################################################################################
  OK if we add a 'source %s' to your '%s' (y/n) [y] ?\n" "${PINGCTL_CONFIG}" "${BASH_PROFILE}"
                read -r answer

                if [ "${answer}" = "" ] || [ "${answer}" = "Y" ] || [ "${answer}" = "y" ]; then
                    printf "
# Ping Identity - Added with '%s config' on $(date)
test -f '%s' && source '%s'\n" "${CMD}" "${PINGCTL_CONFIG}" "${PINGCTL_CONFIG}" >> "${BASH_PROFILE}"
                else
                    printf "Skipping %s\n" "${BASH_PROFILE}"
                fi
            fi
            ;;
        *zsh)
            grep "${PINGCTL_CONFIG}" "${ZSHRC}" > /dev/null
            if test "${?}" = "1"; then
                printf "
################################################################################
# Checking your zsh profile
################################################################################
  OK if we add a 'source %s' to your '%s' (y/n) [y] ?\n" "${PINGCTL_CONFIG}" "${ZSHRC}"
                read -r answer

                if [ "${answer}" = "" ] || [ "${answer}" = "Y" ] || [ "${answer}" = "y" ]; then
                    printf "
# Ping Identity - Added with '%s config' on $(date)
test -f '%s' && source '%s'\n" "${CMD}" "${PINGCTL_CONFIG}" "${PINGCTL_CONFIG}" >> "${ZSHRC}"
                else
                    printf "Skipping %s\n" "${ZSHRC}"
                fi
            fi
            ;;
        *)
            #putting a -s since it'll error if this doesn't exist. If it doesn't then you will need to source it where applicable.
            grep -s "${PINGCTL_CONFIG}" "${DEF_PROFILE}" > /dev/null
            if test "${?}" = "1"; then
                printf "
################################################################################
# Checking all other profiles
################################################################################
OK if we add a 'source %s' to your '%s' (y/n) [y] ?\n" "${PINGCTL_CONFIG}" "${DEF_PROFILE}"
                read -r answer

                if [ "${answer}" = "" ] || [ "${answer}" = "Y" ] || [ "${answer}" = "y" ]; then
                    printf "
# Ping Identity - Added with '%s config' on $(date)
test -f '%s' && . ''\n" "${CMD}" "${PINGCTL_CONFIG}" "${PINGCTL_CONFIG}" >> "${DEF_PROFILE}"
                else
                    printf "Skipping %s\n" "${DEF_PROFILE}"
                fi
            fi
            ;;
    esac

}

################################################################################
# get_custom_variables ()
#
# Obtain a list of custom variables
################################################################################
get_custom_variables() {
    grep -v "^#" "${PINGCTL_CONFIG}" 2> /dev/null |
        while read -r _line; do
            test -z "${_line}" && continue
            _name="${_line%%=*}"

            printf "%s" "${STANDARD_VARIABLES}" | grep "${_name}" > /dev/null
            _grepRC=$?

            if test ${_grepRC} -ne 0; then
                printf "%s\n" "${_name}"
            fi
        done
}

################################################################################
# add_config (file, variable, default, prompt)
#
# Add a config variable to the devops file, using the prompt sent, and defaulting
# if no value is provided.
################################################################################
add_config() {
    PROPS_FILE="${1}" && shift
    VAR_TO_SET="${1}" && shift
    VAR_DEFAULT="${1}" && shift
    VAR_PROMPT="${1}" && shift
    VAR_REQ_OPTIONS="${1}"

    CURRENT_VALUE=$(get_value "${VAR_TO_SET}")
    test -z "${CURRENT_VALUE}" && CURRENT_VALUE="${VAR_DEFAULT}"

    while true; do

        printf "%s\n" "${VAR_PROMPT}"
        printf "    [%s] ?\n" "${CURRENT_VALUE}"
        read -r answer
        printf "\n"

        # If no required options were sent then, simply break out
        if test -z "${VAR_REQ_OPTIONS}"; then
            break
        else
            test -z "${answer}" && answer="${CURRENT_VALUE}"
            eval 'case "${answer}" in
        '"${VAR_REQ_OPTIONS}"') break;;
        *)  printf "Invalid Value [${answer}].  Must be one of [${VAR_REQ_OPTIONS}]\n"
            printf "\n";;
      esac'
        fi
    done

    if test ! -z "${answer}"; then
        if test "${answer}" = "-"; then
            if test -z "${VAR_TO_SET}"; then
                printf >> "${PROPS_FILE}\n"
            else
                eval "unset \${VAR_TO_SET}"

                # If the variable being set is a standard variable, then echo an
                # empty value in the property file, otherwise lose it from new
                # property file
                printf "%s" "${STANDARD_VARIABLES}" | grep "${VAR_TO_SET}" > /dev/null

                test $? -eq 0 && printf "%s=\n" "${VAR_TO_SET}" >> "${PROPS_FILE}"
            fi
        else
            if test -z "${VAR_TO_SET}"; then
                printf "%s\n" "${answer}" >> "${PROPS_FILE}"
            else
                eval "export \${VAR_TO_SET}=${answer}"
                printf "%s=%s\n" "${VAR_TO_SET}" "${answer}" >> "${PROPS_FILE}"
            fi
        fi
    else
        if test -z "${VAR_TO_SET}"; then
            printf "%s\n" "${CURRENT_VALUE}" >> "${PROPS_FILE}"
        else
            eval "export \${VAR_TO_SET}=${CURRENT_VALUE}"
            printf "%s=%s\n" "${VAR_TO_SET}" "${CURRENT_VALUE}" >> "${PROPS_FILE}"
        fi
    fi
}

################################################################################
# print_variable_setting_instructions
################################################################################
print_variable_setting_instructions() {
    printf "
################################################################################
#  Setting Variables:
#      [enter]     to accept current value
#      [-]         to unset the value
#      new value   to change value
################################################################################
\n "
}

################################################################################
# add_config_custom (file)
#
# Add a config variable to the devops file, using the prompt sent, and defaulting
# if no value is provided.
################################################################################
add_config_custom() {
    PROPS_FILE="${1}" && shift
    _custom_variables="${*}"

    test ! -z "${_custom_variables}" && print_variable_setting_instructions

    for _varName in ${_custom_variables}; do
        add_config "${PROPS_FILE}" "${_varName}" "" "Set Custom Variable '${_varName}'"
    done

    printf "
################################################################################
#  Add Additional Variables:
#
#      [enter]     to end adding additional variables
#      NAME=VALUE  to add that variable with setting (i.e. VERBOSE=true)
################################################################################
\n"

    while true; do
        printf "Enter a new NAME=VALUE [enter to end] :\n"

        read -r answer

        test -z "${answer}" && break

        printf "%s\n" "$answer" >> "${PROPS_FILE}"
    done
}

################################################################################
# echo_info_variable
################################################################################
echo_info_variable() {
    _varToEcho="${1}"

    printf "  %-32s : %s\n" "${_varToEcho}" "$(get_value "${_varToEcho}")"
}

################################################################################
# info_command ()
#
# Prints all the variables of the CONFIG_FILE file
################################################################################
info_command() {
    _show="${1}"

    _save_PINGONE_WORKER_APP_CLIENT_SECRET="${PINGONE_WORKER_APP_CLIENT_SECRET}"
    _save_PING_IDENTITY_DEVOPS_KEY="${PING_IDENTITY_DEVOPS_KEY}"

    if test "${_show}" != "-v"; then
        PINGONE_WORKER_APP_CLIENT_SECRET="*** REDACTED *** (use -v to display)"
        PING_IDENTITY_DEVOPS_KEY="*** REDACTED *** (use -v to display)"
    fi

    test ! -f "${PINGCTL_CONFIG}" && _not_found="(NOT FOUND)"

    printf "
################################################################################
#     pingctl CLI (version %s)
#
#                PINGCTL_CONFIG : %s
################################################################################
#     PingOne variables
################################################################################
\n" "${VERSION}" "${PINGCTL_CONFIG} ${_not_found}"
    echo_info_variable PINGONE_API_URL
    echo_info_variable PINGONE_AUTH_URL
    echo_info_variable PINGONE_ENVIRONMENT_ID
    printf "\n"
    echo_info_variable PINGONE_WORKER_APP_CLIENT_ID
    echo_info_variable PINGONE_WORKER_APP_GRANT_TYPE
    echo_info_variable PINGONE_WORKER_APP_REDIRECT_URI
    echo_info_variable PINGONE_WORKER_APP_CLIENT_SECRET
    PINGONE_WORKER_APP_CLIENT_SECRET="${_save_PINGONE_WORKER_APP_CLIENT_SECRET}"

    printf "\n"

    printf "################################################################################
#     Ping DevOps variables
################################################################################
\n"

    echo_info_variable PING_IDENTITY_DEVOPS_USER
    echo_info_variable PING_IDENTITY_DEVOPS_KEY
    PING_IDENTITY_DEVOPS_KEY="${_save_PING_IDENTITY_DEVOPS_KEY}"
    printf "\n"
    echo_info_variable PING_IDENTITY_DEVOPS_HOME
    echo_info_variable PING_IDENTITY_DEVOPS_REGISTRY
    printf "\n"
    echo_info_variable PING_IDENTITY_DEVOPS_TAG
    printf "\n"
    echo_info_variable PING_IDENTITY_ACCEPT_EULA

    _listOfCustom_Variables=$(get_custom_variables)

    if test ! -z "$_listOfCustom_Variables"; then
        printf "
################################################################################
#     Custom Variables
################################################################################
\n"

        for _custVar in $_listOfCustom_Variables; do
            echo_info_variable "${_custVar}"
        done
    fi

    printf "
################################################################################
 To change config, run:
    %s config
\n" "${CMD}"
}

print_update_information() {
    printf "
to update, you can use:
  macosx : brew upgrade pingctl
  linux  : curl -L https://raw.githubusercontent.com/pingidentity/pingctl/master/install.sh | bash\n"
}

################################################################################
# version_command
#
# Prints tool version info
################################################################################
version_command() {
    # Looks for the URL and pulls out the version.  Example should be:
    #
    #      url "https://github.com/pingidentity/pingctl/archive/v0.5.0.tar.gz"
    #
    _latest_tool_version=$(${CURL} https://raw.githubusercontent.com/pingidentity/homebrew-tap/master/Formula/pingctl.rb |
        grep -e '^  url ".*"$' |
        sed "s/.*archive\/v\(.*\)\.tar.*/\1/")

    _curl_result=$?

    test ${_curl_result} -ne 0 || test -z "${_latest_tool_version}" && _latest_tool_version="UNKNOWN"

    if test "${_latest_tool_version}" = "${VERSION}" ||
        test "${_latest_tool_version}" = "UNKNOWN"; then
        _version_msg="${VERSION} (no update required)"
    else
        _version_msg="${VERSION} (updated version ${_latest_tool_version} is available)\n$(print_update_information)"
    fi

    printf "%s version %s\n" "${CMD}" "${_version_msg}"
}

################################################################################
# clean_command
#
# Cleans the ~/.pingidentity/${CMD}
################################################################################
clean_command() {

    printf "\n"
    printf "IMPORTANT: This action will remove all content located under the directory:\n"
    printf "                        %s\n" "${WORK_DIR}"
    printf "\n"
    printf "Are you SURE you want to clean/remove this content? (y/n) [n]\n"
    read -r answer

    if [ "${answer}" != "Y" ] && [ "${answer}" != "y" ]; then
        echo_error "Clean Aborted!"
        exit
    fi

    rm -rf "${WORK_DIR}"
}

################################################################################
# k8s_command
################################################################################
k8s_command() {
    _k8s_cmd="${1}" && shift $(($# > 0 ? 1 : 0))

    case "${_k8s_cmd}" in
        oidc) k8s_oidc_tools "${@}" ;;
        generate) k8s_generate_resource "${@}" ;;
        *) usage_command USAGE_KUBERNETES_DETAIL "unknown/missing Kubernetes command: ${_k8s_cmd}" ;;
    esac

}

################################################################################
# license_command
################################################################################
license_command() {
    _license_prod="${1}" && shift
    _license_ver="${1}" && shift

    test -z "${_license_prod}" && usage_command USAGE_LICENSE_DETAIL "unknown/missing license product"
    test -z "${_license_ver}" && usage_command USAGE_LICENSE_DETAIL "unknown/missing license version"

    generate_license_secret "license" "${_license_prod}" "${_license_ver}"
}

################################################################################
# k8s_oidc_tools
################################################################################
k8s_oidc_tools() {
    _oidc_opt="${1}"

    test -z "${_oidc_opt}" && usage_command USAGE_OIDC_DETAIL "missing Kubernetes oidc command"

    if test ! -d "${KUBE_OIDC_CACHE}"; then
        printf "==  no-token  ==\n"
        exit
    fi

    case "${_oidc_opt}" in
        clear)
            printf "Are you SURE you want to clean/remove %s (y/n) [n]\n" "${KUBE_OIDC_CACHE}"
            read -r answer

            if [ "${answer}" != "Y" ] && [ "${answer}" != "y" ]; then
                echo_error "OIDC cache clear aborted!"
                exit
            fi

            printf "Removing %s\n" "${KUBE_OIDC_CACHE}"
            rm -rf "${KUBE_OIDC_CACHE}"
            ;;
        info)
            check_for_tool ${JWT}
            ${JQ} -r .id_token "${KUBE_OIDC_CACHE}"/* | ${JWT} decode -
            ;;
        *)
            check_for_tool ${JQ}
            check_for_tool ${JWT}
            ${JQ} -r .id_token "${KUBE_OIDC_CACHE}"/* | ${JWT} decode - -j | ${JQ} -r ".payload.${_oidc_opt}"
            ;;
    esac
}

################################################################################
# k8s_generate_resource
################################################################################
k8s_generate_resource() {
    _secret="${1}"

    case "${_secret}" in
        devops-secret)
            check_variables \
                PING_IDENTITY_DEVOPS_USER \
                PING_IDENTITY_DEVOPS_KEY \
                PING_IDENTITY_ACCEPT_EULA

            check_for_tool $BASE64

            # using HEREDOC for longer objects
            cat << DO_SECRET
apiVersion: v1
kind: Secret
metadata:
  name: devops-secret
  annotations:
    ${CMD}.user: ${PING_IDENTITY_DEVOPS_USER}
    ${CMD}.app-version: v${VERSION}
type: Opaque
data:
  PING_IDENTITY_DEVOPS_USER: $(base64_no_newlines "${PING_IDENTITY_DEVOPS_USER}")
  PING_IDENTITY_DEVOPS_KEY: $(base64_no_newlines "${PING_IDENTITY_DEVOPS_KEY}")
  PING_IDENTITY_ACCEPT_EULA: $(base64_no_newlines "${PING_IDENTITY_ACCEPT_EULA}")
DO_SECRET
            ;;

        tls-secret)
            _domain="${2}"
            test -z "${_domain}" && usage "Missing tls-secret domain"

            check_for_tool $OPENSSL
            check_for_tool $BASE64

            test ! -f /etc/ssl/openssl.cnf && echo_error "Missing /etc/ssl/openssl.cnf" && exit

            _opensslcnf="${TMP_DIR}/openssl.cnf"
            _tlsKey="${TMP_DIR}/tls.key"
            _tlsCrt="${TMP_DIR}/tls.crt"

            cat /etc/ssl/openssl.cnf > "${_opensslcnf}"
            printf "[SAN]\nsubjectAltName=DNS:*.%s" "${_domain}" >> "${_opensslcnf}"

            $OPENSSL req -x509 -nodes -newkey rsa:2048 -days 3650 -sha256 \
                -out "${_tlsKey}" -keyout "${_tlsCrt}" \
                -subj "/CN=${_domain}" \
                -reqexts SAN -extensions SAN \
                -config "${_opensslcnf}" > /dev/null 2>&1

            # using HEREDOC for longer objects
            cat << TLS_SECRET
apiVersion: v1
kind: Secret
type: kubernetes.io/tls
metadata:
  name: tls-secret
  annotations:
    ${CMD}.dns-zone: ${_domain}
    ${CMD}.app-version: v${VERSION}
data:
  tls.crt: $(base64_no_newlines "${_tlsCrt}")
  tls.key: $(base64_no_newlines "${_tlsKey}")
TLS_SECRET
            ;;
        ssh-id-secret)
            _idKey="${2}"

            # using HEREDOC for longer objects
            cat << SSH_SECRET
apiVersion: v1
kind: Secret
metadata:
  name: ssh-id-key-secret
data:
  id_rsa: |
    $(base64_no_newlines "${_idKey}")
SSH_SECRET
            ;;
        license-secret)
            generate_license_secret "${@}"
            ;;
        *)
            usage_command USAGE_GENERATE_DETAIL "unknown/missing generate option: ${_secret}"
            ;;
    esac
}

################################################################################
# generate_license_secret (command, name of product or license file)
#
# Generates a license secret for the passed license file or name of product
#  - license {product-name} {product-version}
#  - license-secret {file}
#  - license-secret {product-name} {product-version}
################################################################################
generate_license_secret() {
    _licenseType="${1}"
    _licenseArg="${2}"
    _licenseVer="${3}"

    case "${_licenseType}" in
        license-secret)
            if test -f "${_licenseArg}"; then
                LICENSE_RESPONSE="${_licenseArg}"
                _licenseSecretName="ping-license"
            else
                _licenseProd="${_licenseArg}"
                _licenseSecretName="${_licenseProd}-license"
                test -z "${_licenseProd}" && usage_command USAGE_GENERATE_DETAIL "Missing product name (i.e. pingfederate)"
                test -z "${_licenseVer}" && usage_command USAGE_GENERATE_DETAIL "Missing product version (i.e. 10.2)"
            fi
            ;;
        license)
            _licenseProd="${_licenseArg}"
            test -z "${_licenseProd}" && usage_command USAGE_GENERATE_DETAIL "Missing product name (i.e. pingfederate)"
            test -z "${_licenseVer}" && usage_command USAGE_GENERATE_DETAIL "Missing product version (i.e. 10.2)"
            ;;
        *)
            usage "Unknown generate resource '${_licenseType}"
            ;;
    esac

    #
    # Getting an evaluation license based on product passed
    if test -n "${_licenseProd}"; then
        check_variables \
            PING_IDENTITY_DEVOPS_USER \
            PING_IDENTITY_DEVOPS_KEY

        LICENSE_CALL_RESULT=$($CURL -g --request GET https://license.pingidentity.com/devops/license \
            --header "devops-user: ${PING_IDENTITY_DEVOPS_USER}" \
            --header "devops-key: ${PING_IDENTITY_DEVOPS_KEY}" \
            --header 'devops-app: pingctl' \
            --header 'devops-purpose: download-license' \
            --header "product: ${_licenseProd}" \
            --header "version: ${_licenseVer}" \
            --write-out '%{http_code}' \
            --output "${LICENSE_RESPONSE}")

        test "${LICENSE_CALL_RESULT}" -ne 200 && usage_command USAGE_GENERATE_DETAIL "Unable to pull evaluation license for '${_licenseProd}' version '${_licenseVer}'\n       Check that your PING_IDENTITY_DEVOPS_USER and PING_IDENTITY_DEVOPS_KEY are valid.\n       Check that the product and version specified are valid."
    fi

    case "${_licenseType}" in
        license-secret)
            _licenseSecret=$(base64_no_newlines "${LICENSE_RESPONSE}")

            # using HEREDOC for longer objects
            cat << LIC_SECRET
apiVersion: v1
kind: Secret
metadata:
  name: ${_licenseSecretName}
  labels:
    pingidentity.com/generated-by: ${CMD}
data:
  license: |
    ${_licenseSecret}
LIC_SECRET
            ;;
        license)
            cat "${LICENSE_RESPONSE}"
            ;;
    esac

}

################################################################################
# config_command
################################################################################
config_command() {

    ################################################################################
    # Get all the custom variables from the devops file before we backup
    ################################################################################
    _custom_variables=$(get_custom_variables)

    ################################################################################
    # Check for existence of the devops file and backup to .prev
    ################################################################################
    if test -f "${PINGCTL_CONFIG}"; then
        mv "${PINGCTL_CONFIG}" "${PINGCTL_CONFIG}".prev

        # If the config is broken (i.e. ctrl-c) then restore the previous file
        trap '
            printf "\n"
            # shellcheck disable=SC2059
            printf "restoring: ${PINGCTL_CONFIG}\n"
            mv "${PINGCTL_CONFIG}".prev "${PINGCTL_CONFIG}"
            exit
        ' HUP INT PIPE TERM
    fi

    printf "

################################################################################
#
#                   Welcome to the Ping Identity Command Line Tool!
#
#  We will run through a few configuration items to make your experience as easy as
#  possible.  Actions to be taken include:
#
#    - Setting up your PINGCTL_CONFIG '%s' settings
#    - Source your '%s' in your shell startup files
#\n" "${PINGCTL_CONFIG}" "${PINGCTL_CONFIG}"

    print_variable_setting_instructions

    printf "################################################################################
# Variables used to assist PingOne operations.  If you are not using a PingOne
# environment, you can ignore these settings.
################################################################################
\n" | tee -a "${PINGCTL_CONFIG}"

    add_config "${PINGCTL_CONFIG}" "PINGONE_API_URL" "https://api.pingone.com/v1" "PingOne API URL"
    add_config "${PINGCTL_CONFIG}" "PINGONE_AUTH_URL" "https://auth.pingone.com" "PingOne Authentication URL"
    add_config "${PINGCTL_CONFIG}" "PINGONE_ENVIRONMENT_ID" "" "PingOne Environment ID"

    #
    # Perform a quick test to see if the PINGONE variables can connect
    #
    if test ! -z "${PINGONE_ENVIRONMENT_ID}"; then
        add_config "${PINGCTL_CONFIG}" "PINGONE_WORKER_APP_CLIENT_ID" "" "PingOne Worker App Client ID"
        add_config "${PINGCTL_CONFIG}" "PINGONE_WORKER_APP_GRANT_TYPE" "" "PingOne Worker App Grant Type (valid options: authorization_code, implicit, client_credentials)" "authorization_code|implicit|client_credentials"
        add_config "${PINGCTL_CONFIG}" "PINGONE_WORKER_APP_REDIRECT_URI" "http://localhost:8000" "PingOne Worker App Redirect URI"

        if test "${PINGONE_WORKER_APP_GRANT_TYPE}" = "client_credentials"; then
            add_config "${PINGCTL_CONFIG}" "PINGONE_WORKER_APP_CLIENT_SECRET" "" "PingOne Worker App Client Secret (required for client_credentials grant type)"
        fi

        while true; do
            printf "Would you like to perform a test to validate your PINGONE_WORKER_APP settings? [y] ?\n"
            read -r answer

            if [ "${answer}" = "" ] || [ "${answer}" = "Y" ] || [ "${answer}" = "y" ]; then
                printf "############################################################################\n"
                printf "#  Attempting to retrieve token for:\n"
                printf "#    Worker App Client Id: %s\n" "${PINGONE_WORKER_APP_CLIENT_ID}"
                printf "#        using Grant Type: %s\n" "${PINGONE_WORKER_APP_GRANT_TYPE}"
                printf "#            Redirect URI: %s\n" "${PINGONE_WORKER_APP_REDIRECT_URI}"
                printf "############################################################################\n"
                printf "\n"
                getPingOneAccessToken true

                if test -z "${PINGONE_ACCESS_TOKEN}"; then
                    troubleshootPingOneSettings
                else
                    printf "\n"
                    printf "Congrats!  You've obtained a valid access_token.\n"
                    printf "\n"
                    break
                fi
            else
                break
            fi
        done
    fi

    printf "################################################################################
# Variables used to assist Ping DevOps operations.
################################################################################
\n" | tee -a "${PINGCTL_CONFIG}"

    add_config "${PINGCTL_CONFIG}" "PING_IDENTITY_ACCEPT_EULA" "NO" "Do you accept the terms of license (found here: https://www.pingidentity.com/en/legal/subscription-agreement.html) with Ping Identity? (YES/NO)"
    add_config "${PINGCTL_CONFIG}" "PING_IDENTITY_DEVOPS_USER" "" "Ping Identity DevOps User (Register under Support & Community: https://www.pingidentity.com/en/account/sign-on.html)"
    add_config "${PINGCTL_CONFIG}" "PING_IDENTITY_DEVOPS_KEY" "" "Ping Identity DevOps Key"
    add_config "${PINGCTL_CONFIG}" "PING_IDENTITY_DEVOPS_HOME" "${HOME}/projects/devops" "Location of Ping Identity DevOps repos and tools"
    add_config "${PINGCTL_CONFIG}" "PING_IDENTITY_DEVOPS_REGISTRY" "docker.io/pingidentity" "Ping Identity DevOps Registry (recommend default: docker.io/pingidentity)"
    add_config "${PINGCTL_CONFIG}" "PING_IDENTITY_DEVOPS_TAG" "edge" "Ping Identity DevOps Tag (recommend default: edge)"

    printf "
################################################################################
#              Ping Identity Customized Variables
################################################################################
# Additional variables that you would like to set for DevOps Containers or
# optional variables to help with PingOne credentials/output.
#
# Examples include:
#     PINGONE_USERNAME=jsmith@example.com
#     PINGONE_PASSWORD=......... (*** CONSIDERED UNSECURE ***)
#
#     PINGCTL_OUTPUT_COLUMNS_USERS=FirstName:name.given,LastName:name.family
#     PINGCTL_OUTPUT_SORT_USERS=name.given
#
# These variables are often set to empty values except when using advanced features
################################################################################
\n" | tee -a "${PINGCTL_CONFIG}"

    add_config_custom "${PINGCTL_CONFIG}" "${_custom_variables}"

    test "${PINGCTL_CONFIG}" = "${DEFAULT_PINGCTL_CONFIG}" && source_config

    printf "

################################################################################
#
# To make these changes effective to the shell, please do one of the following:
#
#    o If you selected to add a source referencing .pingidentity
#        - Restart your terminal session
#
#    o Alternatively, source the current profile to load the new reference:
#        - bash   - 'source ~/.bash_profile'
#        - zsh    - 'source ~/.zshrc
#        - others - '. ~/.profile'
#
#    o If you did not accept the prompt to source, add the following
#      line to your profile of choice:
#
#       . \"~/.pingidentity/config\"
#
#
################################################################################
    \n"
}

########################################################################################################################
# base64-encode the provided string or file contents and remove any new lines (both line feeds and carriage returns).
#
# Arguments
#   ${1} -> The string to base-64 encode, or a file whose contents to base64-encode.
########################################################################################################################
base64_no_newlines() {
    if test -f "${1}"; then
        # shellcheck disable=SC2002
        cat "${1}" | $BASE64 | tr -d '\r?\n'
    else
        printf "%s" "${1}" | $BASE64 | tr -d '\r?\n'
    fi
}

################################################################################
# troubleshootPingOneSettings
################################################################################
troubleshootPingOneSettings() {
    echo_error "Unable to validate PingOne settings."
    printf "############################################################################\n"
    printf "# There are a number of reasons why this did not work...\n"
    printf "#\n"
    printf "#   - Incorrect Username/Password (authorization_code, implicit flows)\n"
    printf "#   - Incorrect Client ID\n"
    printf "#   - Incorrect Client Type - Must be Worker App\n"
    printf "#   - Incorrect Redirect URI - You've specified: %s\n" "${PINGONE_WORKER_APP_REDIRECT_URI}"
    printf "#   - Incorrect Client Grant Type Settings\n"
    printf "#\n"

    case "${PINGONE_WORKER_APP_GRANT_TYPE}" in
        authorization_code)
            printf "#     - authorization_code (w/ pkce) (recommended)\n"
            printf "#                Response Type: Code\n"
            printf "#                   Grant Type: Authorization Code\n"
            printf "#             PKCE Enforcement: S256_REQUIRED (recommended)\n"
            printf "#  Token Endpoint AuthN Method: None\n"
            ;;
        implicit)
            printf "#     - implicit\n"
            printf "#                Response Type: Token\n"
            printf "#                   Grant Type: Implicit\n"
            printf "#  Token Endpoint AuthN Method: None\n"
            ;;
        client_credentials)
            printf "#     - client_credentials\n"
            printf "#                Client Secret: %s\n" "${PINGONE_WORKER_APP_CLIENT_SECRET}"
            printf "#                Response Type: Token\n"
            printf "#                   Grant Type: Client Credentials\n"
            printf "#  Token Endpoint AuthN Method: Client Secret Basic\n"
            ;;
        *) printf "#     - INVALID Grant Type: %s\n" "${PINGONE_WORKER_APP_GRANT_TYPE}" ;;
    esac

    printf "############################################################################\n"
}

################################################################################
# getPingOneAccessTokenViaClientCredentials
################################################################################
getPingOneAccessTokenViaClientCredentials() {
    _clearToken="${1}"

    check_variables \
        PINGONE_WORKER_APP_CLIENT_SECRET

    _url="${PINGONE_AUTH_URL}/${PINGONE_ENVIRONMENT_ID}/as/token"

    PINGONE_CALL_RESULT=$($CURL --request POST "${_url}" \
        --header 'Content-Type: application/x-www-form-urlencoded' \
        --user "${PINGONE_WORKER_APP_CLIENT_ID}:${PINGONE_WORKER_APP_CLIENT_SECRET}" \
        --data 'grant_type=client_credentials' \
        --write-out '%{http_code}' \
        --output "${PINGONE_CALL_RESPONSE}")

    #
    # Print out DEBUG info
    #
    if test "${OPT_PINGONE_r}" = "true"; then
        (
            printf "       POST: %s\n" "${_url}"
            printf "       data: grant_type=client_credentials\n"
            printf "       user: %s:*************\n" "${PINGONE_WORKER_APP_CLIENT_ID}"
            printf "\n"
            printf "Result Code: %s\n" "${PINGONE_CALL_RESULT}"
            printf "======================================\n"
        ) >> "${PINGONE_DEBUG}"
    fi

    error_pingone_call 200
    test $? -eq 1 && return

    PINGONE_ACCESS_TOKEN=$(${JQ} --raw-output '.access_token' < "${PINGONE_CALL_RESPONSE}" | tee "${PINGONE_ACCESS_TOKEN_FILE}")
}

################################################################################
# getPingOneAccessTokenViaAuthorizationCode
################################################################################
getPingOneAccessTokenViaAuthorizationCode() {
    _clearToken="${1}"

    _az_verifier=$(env LC_CTYPE=C tr -cd 'a-zA-Z0-9' < /dev/urandom | head -c 50)
    # printf "Verifier is: $VERIFIER\n"

    # Get the correct sha 256 checksum tool, as it's different on mac/linux
    printf "\n" | sha256sum 2> /dev/null > /dev/null && test $? -eq 0 && SHASUM="sha256sum"
    printf "\n" | shasum -a 256 2> /dev/null > /dev/null && test $? -eq 0 && SHASUM="shasum -a 256"

    if test -z "${SHASUM}"; then
        echo_error "Unable to find a suitable SHA 256 Checksum tool required to create OIDC PKCE Challenge.  (tried both sha256sum and shasum)"
        exit
    fi

    # Generate PKCE Challenge from Verifier and convert / + = characters"
    _az_challenge=$(printf "%s" "${_az_verifier}" | ${SHASUM} | cut -d " " -f 1 | xxd -r -p | ${BASE64} | tr / _ | tr + - | tr -d =)

    ########################################################################
    # Start with a request for an AUTHORIZATION_CODE flow...

    _url="${PINGONE_AUTH_URL}/${PINGONE_ENVIRONMENT_ID}/as/authorize"

    _az_flow_id=$(curl -G --request GET "${_url}" \
        --header 'Content-Type: application/x-www-form-urlencoded' \
        --data 'response_type=code' \
        --data "client_id=${PINGONE_WORKER_APP_CLIENT_ID}" \
        --data 'scope=openid' \
        --data "redirect_uri=${PINGONE_WORKER_APP_REDIRECT_URI}" \
        --data "code_challenge=${_az_challenge}" \
        --data "code_challenge_method=S256" \
        --write-out '%{redirect_url}' 2> /dev/null | awk -F "flowId=" '{print $2}')

    #
    # Print out DEBUG info
    #
    if test "${OPT_PINGONE_r}" = "true"; then
        (
            printf "        GET: %s\n" "${_url}"
            printf "      query: response_type=code\n"
            printf "           : client_id=%s\n" "${PINGONE_WORKER_APP_CLIENT_ID}"
            printf "           : code_challenge=%s\n" "${_az_challenge}"
            printf "\n"
            printf "Result Code: %s\n" "${_az_challenge}"
            printf "     flowId: %s\n" "${_az_flow_id}"
            printf "======================================\n"
        ) >> "${PINGONE_DEBUG}"
    fi

    test -z "${_az_flow_id}" && echo_error "Unable to start Authorization Code flow\n\nOften issue with client_id or mis-configured client" && return

    ########################################################################
    # Login with user/password
    authenticatePingOneUser

    error_pingone_call 200
    test $? -eq 1 && return

    ########################################################################
    # Get the Authorization Code...

    _url="${PINGONE_AUTH_URL}/${PINGONE_ENVIRONMENT_ID}/as/resume"

    _az_code=$(curl -b "${_pingone_cookies}" -G --request GET "${_url}" \
        --data "flowId=${_az_flow_id}" \
        --write-out '%{redirect_url}' 2> /dev/null | awk -F "code=" '{print $2}')

    #
    # Print out DEBUG info
    #
    if test "${OPT_PINGONE_r}" = "true"; then
        (
            printf "        GET: %s\n" "${_url}"
            printf "      query: flowId=%s\n" "${_az_flow_id}"
            printf "\n"
            printf "Result Code: %s\n" "${PINGONE_CALL_RESULT}"
            printf "    AZ Code: %s\n" "${_az_code}"
            printf "======================================\n"
        ) >> "${PINGONE_DEBUG}"
    fi

    test -z "${_az_code}" && echo_error "Unable to get Authorization Code" && return

    ########################################################################
    # Trade in the Authorization Code for an access_token, along with the pkce verifier

    _url="${PINGONE_AUTH_URL}/${PINGONE_ENVIRONMENT_ID}/as/token"

    PINGONE_CALL_RESULT=$($CURL --request POST "${_url}" \
        --header 'Content-Type: application/x-www-form-urlencoded' \
        --data "client_id=${PINGONE_WORKER_APP_CLIENT_ID}" \
        --data "grant_type=authorization_code" \
        --data "code=${_az_code}" \
        --data "redirect_uri=${PINGONE_WORKER_APP_REDIRECT_URI}" \
        --data "code_verifier=${_az_verifier}" \
        --write-out '%{http_code}' \
        --output "${PINGONE_CALL_RESPONSE}")

    #
    # Print out DEBUG info
    #
    if test "${OPT_PINGONE_r}" = "true"; then
        (
            printf "       POST: %s\n" "${_url}"
            printf "      query: client_id=%s\n" "${PINGONE_WORKER_APP_CLIENT_ID}"
            printf "           : grant_type=authorization_code\n"
            printf "           : code=%s\n" "${_az_code}"
            printf "           : code_verifier=%s\n" "${_az_verifier}"
            printf "\n"
            printf "Result Code: %s\n" "${PINGONE_CALL_RESULT}"
            printf "======================================\n"
        ) >> "${PINGONE_DEBUG}"
    fi

    error_pingone_call 200
    test $? -eq 1 && return

    PINGONE_ACCESS_TOKEN=$(${JQ} --raw-output '.access_token' < "${PINGONE_CALL_RESPONSE}" | tee "${PINGONE_ACCESS_TOKEN_FILE}")
}

################################################################################
# getPingOneAccessTokenViaImplicit
################################################################################
getPingOneAccessTokenViaImplicit() {
    _clearToken="${1}"

    ########################################################################
    # Start with a request for an AUTHORIZATION_CODE flow...

    _url="${PINGONE_AUTH_URL}/${PINGONE_ENVIRONMENT_ID}/as/authorize"

    _az_flow_id=$(curl --request POST "${_url}" \
        --header 'Content-Type: application/x-www-form-urlencoded' \
        --data-urlencode 'response_type=token' \
        --data-urlencode "client_id=${PINGONE_WORKER_APP_CLIENT_ID}" \
        --data-urlencode 'scope=openid' \
        --data-urlencode "redirect_uri=${PINGONE_WORKER_APP_REDIRECT_URI}" \
        --write-out '%{redirect_url}' 2> /dev/null | awk -F "flowId=" '{print $2}')

    #
    # Print out DEBUG info
    #
    if test "${OPT_PINGONE_r}" = "true"; then
        (
            printf "        GET: %s\n" "${_url}"
            printf "      query: response_type=token\n"
            printf "           : client_id=%s\n" "${PINGONE_WORKER_APP_CLIENT_ID}"
            printf "\n"
            printf "Result Code: %s\n" "${PINGONE_CALL_RESULT}"
            printf "     flowId: %s\n" "${_az_flow_id}"
            printf "======================================\n"
        ) >> "${PINGONE_DEBUG}"
    fi

    test -z "${_az_flow_id}" && echo_error "Unable to start Implicit Grant Flow\n\nOften issue with client_id or mis-configured client" && return

    ########################################################################
    # Login with user/password
    authenticatePingOneUser

    error_pingone_call 200
    test $? -eq 1 && return

    ########################################################################
    # Get the access_token...

    _url="${PINGONE_AUTH_URL}/${PINGONE_ENVIRONMENT_ID}/as/resume"

    PINGONE_ACCESS_TOKEN=$(curl -b "${_pingone_cookies}" -G --request GET "${_url}" \
        --data "flowId=${_az_flow_id}" \
        --write-out '%{redirect_url}' 2> /dev/null | sed -n 's/.*access_token=\([^\&]*\).*/\1/p')

    #
    # Print out DEBUG info
    #
    if test "${OPT_PINGONE_r}" = "true"; then
        (
            printf "        GET: %s\n" "${_url}"
            printf "      query: flowId=%s\n" "${_az_flow_id}"
            printf "\n"
            printf "Result Code: %s\n" "${PINGONE_CALL_RESULT}"
            printf " access_tok: %s\n" "${_az_code}"
            printf "======================================\n"
        ) >> "${PINGONE_DEBUG}"
    fi

    test -z "${PINGONE_ACCESS_TOKEN}" && echo_error "Unable to get access_token" && return

    printf "%s\n" "${PINGONE_ACCESS_TOKEN}" > "${PINGONE_ACCESS_TOKEN_FILE}"
}

################################################################################
# authenticatePingOneUser
################################################################################
authenticatePingOneUser() {
    ########################################################################
    # Get the user/password...

    _pingone_cookies="${TMP_DIR}/pingone.cookies"
    _pingone_username_password="${TMP_DIR}/pingone.auth"

    test -n "${PINGONE_PASSWORD}" && _mask_password="********"

    printf " What is your username [%s]?\n" "${PINGONE_USERNAME}"
    read -r _answer
    test -n "${_answer}" && PINGONE_USERNAME="${_answer}"

    printf "          and password [%s]?\n" "${_mask_password}"
    read -r _answer
    printf "\n"
    test -n "${_answer}" && PINGONE_PASSWORD="${_answer}"

    check_for_tool ${JQ}

    # jq command expects no expansion of variables. Disable shellcheck.
    # shellcheck disable=SC2016,SC2154
    $JQ -n '{username:$username,password:$password}' \
        --arg username "${PINGONE_USERNAME}" \
        --arg password "${PINGONE_PASSWORD}" > "${_pingone_username_password}"

    ########################################################################
    # Login with user/password

    _pingone_cookies="${TMP_DIR}/pingone.cookies"

    _url="${PINGONE_AUTH_URL}/${PINGONE_ENVIRONMENT_ID}/flows/${_az_flow_id}"

    PINGONE_CALL_RESULT=$($CURL -c "${_pingone_cookies}" --request POST "${_url}" \
        --header 'Content-Type: application/vnd.pingidentity.usernamePassword.check+json' \
        --data "@${_pingone_username_password}" \
        --write-out '%{http_code}' \
        --output "${PINGONE_CALL_RESPONSE}")

    #
    # Print out DEBUG info
    #
    if test "${OPT_PINGONE_r}" = "true"; then
        (
            printf "       POST: %s\n" "${_url}"
            printf "       data: {username:....,password:....}\n"
            printf "\n"
            printf "Result Code: %s\n" "${PINGONE_CALL_RESULT}"
            printf "======================================\n"
        ) >> "${PINGONE_DEBUG}"
    fi
}

################################################################################
# getPingOneAccessToken
################################################################################
getPingOneAccessToken() {
    _clearToken="${1}"

    if test "${_clearToken}" = "true"; then
        rm -f "${PINGONE_ACCESS_TOKEN_FILE}"
        PINGONE_ACCESS_TOKEN=""
    fi

    check_variables \
        PINGONE_API_URL \
        PINGONE_AUTH_URL \
        PINGONE_ENVIRONMENT_ID \
        PINGONE_WORKER_APP_CLIENT_ID

    #
    # Check the current token file.  If it has the same client-id and expires more than 60 seconds
    # then use it, otherwise, get a new token.
    #
    if test -f "${PINGONE_ACCESS_TOKEN_FILE}"; then
        ${JWT} --version 2> /dev/null > /dev/null

        if test ${?} -eq 0; then
            _expire=$(${JWT} decode - -j < "${PINGONE_ACCESS_TOKEN_FILE}" | $JQ -r ".payload.exp")
            _client_id=$(${JWT} decode - -j < "${PINGONE_ACCESS_TOKEN_FILE}" | ${JQ} -r ".payload.client_id")
            _now=$(date +%s)

            if test "${PINGONE_WORKER_APP_CLIENT_ID}" = "${_client_id}" && test $((_expire - 60)) -gt "${_now}"; then
                PINGONE_ACCESS_TOKEN=$(cat "${PINGONE_ACCESS_TOKEN_FILE}")
            fi
        fi
    fi

    if test -z "${PINGONE_ACCESS_TOKEN}"; then
        case "${PINGONE_WORKER_APP_GRANT_TYPE}" in
            client_credentials)
                getPingOneAccessTokenViaClientCredentials "${@}"
                ;;
            authorization_code)
                getPingOneAccessTokenViaAuthorizationCode "${@}"
                ;;
            implicit)
                getPingOneAccessTokenViaImplicit "${@}"
                ;;
            *)
                echo_error "Unknown PINGONE_WORKER_APP_GRANT_TYPE [${PINGONE_WORKER_APP_GRANT_TYPE}]" && exit
                ;;
        esac
    fi
}

################################################################################
# print_api_results
################################################################################
print_api_results() {
    case "${PINGCTL_DEFAULT_OUTPUT}" in
        table) print_api_results_sv "tsv" "${@}" ;;
        csv) print_api_results_sv "csv" "${@}" ;;
        json) print_api_results_json "${@}" ;;
        *) usage_command "${USAGE_CONTEXT}" "Unknown output format (-o | PINGCTL_DEFAULT_OUTPUT)=${PINGCTL_DEFAULT_OUTPUT}" ;;
    esac
}

################################################################################
# print_api_results_sv
################################################################################
print_api_results_sv() {
    _sv="${1}" && shift
    _res_obj="${1}"

    _res_obj=$(printf "%s" "${_res_obj}" | tr '[:lower:]' '[:upper:]')

    ################################################################################
    # Table/CSV Columns and Sorts
    ################################################################################
    _default_columns="ID:id"
    _default_sort="id"
    ################################################################################
    PINGCTL_OUTPUT_COLUMNS_USERS=${PINGCTL_OUTPUT_COLUMNS_USERS:-
      USERNAME  :username,
      FIRST     :name.given,
      LAST      :name.family,
      EMAIL     :email,
      POPULATION:population.id}
    PINGCTL_OUTPUT_SORT_USERS=${PINGCTL_OUTPUT_SORT_USERS:-username}
    ################################################################################
    PINGCTL_OUTPUT_COLUMNS_GROUPS=${PINGCTL_OUTPUT_COLUMNS_GROUPS:-
      NAME      :name,
      MEMBERS   :directMemberCounts.users,
      POPULATION:population.id}
    PINGCTL_OUTPUT_SORT_GROUPS=${PINGCTL_OUTPUT_SORT_GROUPS:-name}
    ################################################################################
    PINGCTL_OUTPUT_COLUMNS_GROUPMEMBERSHIPS=${PINGCTL_OUTPUT_COLUMNS_GROUPMEMBERSHIPS:-
      GROUPS   :name}
    PINGCTL_OUTPUT_SORT_GROUPMEMBERSHIPS=${PINGCTL_OUTPUT_SORT_GROUPMEMBERSHIPS:-name}
    ################################################################################
    PINGCTL_OUTPUT_COLUMNS_POPULATIONS=${PINGCTL_OUTPUT_COLUMNS_POPULATIONS:-
      NAME   :name,
      MEMBERS:userCount}
    PINGCTL_OUTPUT_SORT_POPULATIONS=${PINGCTL_OUTPUT_SORT_POPULATIONS:-name}
    ################################################################################

    #
    # if user has supplied a COLUMNS and SORT setting, override with that
    #
    # shellcheck disable=SC2154
    test -n "${OPT_PINGONE_c}" && eval "export PINGCTL_OUTPUT_COLUMNS_\${_res_obj}=\"\${OPT_PINGONE_c}\""
    # shellcheck disable=SC2154
    test -n "${OPT_PINGONE_s}" && eval "export PINGCTL_OUTPUT_SORT_\${_res_obj}=\"\${OPT_PINGONE_s}\""

    #
    # Set the columns and sort to column based on resource object
    #
    _columns=$(get_value "PINGCTL_OUTPUT_COLUMNS_${_res_obj}")
    _sort_column=$(get_value "PINGCTL_OUTPUT_SORT_${_res_obj}")

    #
    # If not set, then set the the default
    #
    test -z "${_columns}" && _columns="${_default_columns}"
    test -z "${_sort_column}" && _sort_column="${_default_sort}"

    #
    # Ensure that the sort column is in the list of columns
    #
    case "${_columns}" in
        *:${_sort_column}*) ;;
        *)
            echo_error "Sort column '${_sort_column}' not found in columns '${_columns}'"
            exit
            ;;
    esac

    #
    # Ensure that each column starts with a dot (.) Required for jq
    #
    _columns=$(printf "%s" "${_columns}" | sed -e 's/:/:./g')

    test "${_sv}" = "tsv" && _dash_row='| (.,map(length*"-"))'

    ${JQ} -s -r "
    .
    | [sort_by(.${_sort_column}) | .[]
    |
        {
            ${_columns}
        }
    ]
    # lowercase keys |  [.[] | with_entries( .key |= ascii_downcase ] )
    |  [.[] ]
    # (for predictable sorting, optional)
    |    (.[0] | keys_unsorted ${_dash_row} |@${_sv}  )               # print headers
        , (.[]|.|map(.) |@${_sv})                       # print table
    " < "${PINGONE_API_RESULTS}" | column -t -s "$(printf '\t')"

    if test "${_sv}" = "tsv"; then
        printf "==\n"
        printf "%s '%s' returned %s\n" "${PINGONE_RESULT_COUNT}" "${_res_obj}" "${_in_population}"
    fi
}

################################################################################
# get_api_attr
################################################################################
get_api_attr() {
    ${JQ} -r ".${1}" < "${PINGONE_API_RESULTS}"
}

################################################################################
# print_api_results_json
################################################################################
print_api_results_json() {
    ${JQ} -s . < "${PINGONE_API_RESULTS}"
}

################################################################################
# pingone_api_get_and_print
################################################################################
pingone_api_get_and_print() {
    pingone_api_get "${@}" true
}

################################################################################
# pingone_api_get
################################################################################
pingone_api_get() {
    _pingone_resource="${1}" && shift
    _api_filter="${1}" && shift
    _print_results="${1}"

    rm -f "${PINGONE_API_RESULTS}"

    case "${_pingone_resource}" in
        organization)
            _api_url="organizations/${_api_filter}"
            _res_obj="organizations"
            _json_res=""
            ;;
        environment)
            _api_url="environments/${PINGONE_ENVIRONMENT_ID}"
            _res_obj="environments"
            _json_res=""
            ;;
        users/*/memberOfGroups)
            _api_url="environments/${PINGONE_ENVIRONMENT_ID}/${_pingone_resource}"
            _res_obj="groupMemberships"
            _json_res="_embedded.${_res_obj}[]"
            ;;
        users/*)
            _api_url="environments/${PINGONE_ENVIRONMENT_ID}/${_pingone_resource}"
            _res_obj="users"
            _json_res=""
            ;;
        groups/*)
            _api_url="environments/${PINGONE_ENVIRONMENT_ID}/${_pingone_resource}"
            _res_obj="groups"
            _json_res=""
            ;;
        populations/*)
            _api_url="environments/${PINGONE_ENVIRONMENT_ID}/${_pingone_resource}"
            _res_obj="populations"
            _json_res=""
            ;;
        *)
            _api_url="environments/${PINGONE_ENVIRONMENT_ID}/${_pingone_resource}"
            _res_obj="${_pingone_resource}"
            _json_res="_embedded.${_res_obj}[]"
            ;;
    esac

    _url="${PINGONE_API_URL}/${_api_url}"

    #
    # Loop through this while loop for each page of results, until all are exhausted
    #
    while test ! -z "${_url}"; do
        PINGONE_CALL_RESULT=$($CURL -G --request GET "${_url}" \
            --data-urlencode "${_api_filter}" \
            --data-urlencode "limit=100" \
            --header 'Content-Type: application/json' \
            --header "Authorization: Bearer ${PINGONE_ACCESS_TOKEN}" \
            --write-out '%{http_code}' \
            --output "${PINGONE_CALL_RESPONSE}")

        #
        # Print out DEBUG info
        #
        if test "${OPT_PINGONE_r}" = "true"; then
            (
                printf "        GET: %s\n" "${_url}"
                test ! -z "${_filter}" && printf "      query: %s\n" "${_api_filter}"
                printf "\n"
                printf "Result Code: %s\n" "${PINGONE_CALL_RESULT}"
                # nested printf redirect
                # shellcheck disable=SC2059
                printf "  Page Size: $(echo "${PINGONE_CALL_RESPONSE}" | ${JQ} .size)"
                # shellcheck disable=SC2059
                printf " Total Size: $(echo "${PINGONE_CALL_RESPONSE}" | ${JQ} .count)"
                printf "======================================\n"
            ) >> "${PINGONE_DEBUG}"
        fi

        error_pingone_call 200

        _url=""

        if test -s "${PINGONE_CALL_RESPONSE}"; then
            ${JQ} ".${_json_res}" < "${PINGONE_CALL_RESPONSE}" >> "${PINGONE_API_RESULTS}"

            _next=$(${JQ} ._links.next < "${PINGONE_CALL_RESPONSE}")

            if test "${_next}" != "null"; then
                _url=$(printf "%s" "${_next}" | ${JQ} -r .href)
                _api_filter=""
            fi
        fi

    done

    PINGONE_RESULT_ID=""
    PINGONE_RESULT_COUNT=0
    #
    # If there is one item found, then place the ID into the PINGONE_RESULT_ID
    # Also get the PINGONE_RESULT_COUNT
    #
    if test -s "${PINGONE_API_RESULTS}"; then
        PINGONE_RESULT_COUNT=$(${JQ} -s '. | length' < "${PINGONE_API_RESULTS}")

        if test "${PINGONE_RESULT_COUNT}" -eq 1; then
            PINGONE_RESULT_ID="$(${JQ} -s -r '.[0].id' < "${PINGONE_API_RESULTS}")"
        fi
    fi

    #
    # Print the Results
    #
    if test "${_print_results}" = true; then
        if test -s "${PINGONE_API_RESULTS}"; then
            print_api_results "${_res_obj}"
        else
            printf "No '%s' found %s\n" "${_res_obj}" "${_in_population}"
        fi
    fi
}

################################################################################
# error_pingone_call
#
# SUCCESS - Return 0
# FAILURE - Return 1
################################################################################
error_pingone_call() {
    _expected_result="${1}"

    test "${PINGONE_CALL_RESULT}" = "${_expected_result}" && return 0

    print_rest_debug

    if test -f "${PINGONE_CALL_RESPONSE}"; then
        _possible_errors=".error_description .details[].message .message"

        for _error_try in $_possible_errors; do
            _err_message=$(${JQ} -r "${_error_try}" < "${PINGONE_CALL_RESPONSE}" 2> /dev/null)
            if test $? -eq 0 && test "${_err_message}" != "null"; then
                printf "ERROR: %s\n" "${_err_message}"
            fi
        done

        # ${JQ} . <"${PINGONE_CALL_RESPONSE}"
    fi

    return 1
}

################################################################################
# pingone_api_post
################################################################################
pingone_api_post() {
    _res_object="${1}"

    _url="${PINGONE_API_URL}/environments/${PINGONE_ENVIRONMENT_ID}/${_res_object}"

    PINGONE_CALL_RESULT=$($CURL --request POST \
        -g "${_url}" \
        --data-binary @"${PINGONE_POST_JSON}" \
        --header 'Content-Type: application/json' \
        --header "Authorization: Bearer ${PINGONE_ACCESS_TOKEN}" \
        --write-out '%{http_code}' \
        --output "${PINGONE_CALL_RESPONSE}")

    #
    # Print out DEBUG info
    #
    if test "${OPT_PINGONE_r}" = "true"; then
        (
            printf "       POST: %s\n" "${_url}"
            # parsing throwing shellcheck
            # shellcheck disable=SC2059
            printf "       BODY: $(%s -c . \< %s)\n" "${JQ}" "${PINGONE_POST_JSON}"
            printf "\n"
            printf "Result Code: %s\n" "${PINGONE_CALL_RESULT}"
            printf "======================================\n"
        ) >> "${PINGONE_DEBUG}"
    fi

    error_pingone_call 201
}

################################################################################
# pingone_delete_by_filter
################################################################################
pingone_api_delete_by_filter() {
    _res_obj="${1}" && shift
    _filter="${1}" && shift

    pingone_api_get "${_res_obj}" "filter=${_filter}"

    if test ! -z "${PINGONE_RESULT_ID}"; then
        pingone_api_delete "${_res_obj}" "${PINGONE_RESULT_ID}"
    else
        printf "'%s' not found in %s\n" "${_res_name}" "${_res_obj}" && exit
    fi
}

################################################################################
# pingone_api_delete
################################################################################
pingone_api_delete() {
    _res_obj="${1}" && shift
    _obj_id="${1}" && shift

    _url="${PINGONE_API_URL}/environments/${PINGONE_ENVIRONMENT_ID}/${_res_obj}/${_obj_id}"

    PINGONE_CALL_RESULT=$($CURL --request DELETE \
        -g "${_url}" \
        --header 'Content-Type: application/json' \
        --header "Authorization: Bearer ${PINGONE_ACCESS_TOKEN}" \
        --write-out '%{http_code}' \
        --output "${PINGONE_CALL_RESPONSE}")

    #
    # Print out DEBUG info
    #
    if test "${OPT_PINGONE_r}" = "true"; then
        (
            printf "     DELETE: %s\n" "${_url}"
            printf "\n"
            printf "Result Code: %s\n" "${PINGONE_CALL_RESULT}"
            printf "======================================\n"
        ) >> "${PINGONE_DEBUG}"
    fi

    case "${PINGONE_CALL_RESULT}" in
        200 | 204 | 404) ;;
        *) error_pingone_call 204 ;;
    esac

}

################################################################################
# pingone_print_environment
################################################################################
pingone_print_environment() {
    test -z "${PINGONE_ENVIRONMENT_ID}" && return

    getPingOneAccessToken true

    printf "
################################################################################
#     PingOne Environment/Organization Current Info
################################################################################\n"
    printf "\n"

    if test -z "${PINGONE_ACCESS_TOKEN}"; then
        echo_error "Unable to validate (authenticate) PingOne settings.  Re-run config to resolve."
    else
        pingone_api_get "environment" ""

        _env_name=$(get_api_attr name)
        _org_id=$(get_api_attr organization.id)

        pingone_api_get "organization" "${_org_id}"
        _org_name=$(get_api_attr name)

        printf "  ORGANIZATION NAME              : %s\n" "${_org_name}"
        printf "  ENVIRONMENT NAME               : %s\n" "${_env_name}"
    fi
}

################################################################################
# pingone_get
################################################################################
pingone_get() {
    USAGE_CONTEXT="USAGE_PINGONE_GET_DETAIL"
    _resource="${1}" && shift
    test -z "${_resource}" && usage_command

    get_pingone_options "${@}"
    # Remove the switches we parsed above.
    shift "$((OPTIND - 1))"

    _exact_id=""
    _filter=""

    #
    # In ORDER
    # 1 - Process by ID (i)
    # 2 - Process by NAME (n)
    # 3 - Process by FILTER (f)
    # shellcheck disable=SC2154
    if test ! -z "${OPT_PINGONE_i}"; then
        _exact_id="/${OPT_PINGONE_i}"
    elif test ! -z "${OPT_PINGONE_n}"; then
        if test "${_resource}" = "users"; then
            _filter="filter=username eq \"${OPT_PINGONE_n}\""
        else
            _filter="filter=name eq \"${OPT_PINGONE_n}\""
        fi
    elif test ! -z "${OPT_PINGONE_f}"; then
        _filter="filter=${OPT_PINGONE_f}"
    fi

    #
    # if -p (population) is provided, then we will add that to the
    # filter
    #
    if test "${_resource}" != "populations" && test -n "${PINGCTL_DEFAULT_POPULATION}"; then
        pingone_api_get "populations" "filter=name eq \"${PINGCTL_DEFAULT_POPULATION}\""

        test -z "${PINGONE_RESULT_ID}" && echo_error "Unknown population '${PINGCTL_DEFAULT_POPULATION}'" && exit
        _pop_filter="population.id eq \"${PINGONE_RESULT_ID}\""

        if test -z "${_filter}"; then
            _filter="filter=${_pop_filter}"
        else
            _filter="${_filter} and ${_pop_filter}"
        fi

        #
        # used when printing totals in table format
        #
        _in_population="in population '${PINGCTL_DEFAULT_POPULATION}'"
    fi

    case "${_resource}" in
        users)
            pingone_api_get_and_print "users${_exact_id}" "${_filter}"

            if test -n "${PINGONE_RESULT_ID}"; then
                printf "\n"
                pingone_api_get_and_print "users/${PINGONE_RESULT_ID}/memberOfGroups" ""
            fi
            ;;
        groups)
            pingone_api_get_and_print "groups${_exact_id}" "${_filter}"

            if test -n "${PINGONE_RESULT_ID}"; then
                printf "\n"
                pingone_api_get_and_print "users" "filter=memberOfGroups[id eq \"${PINGONE_RESULT_ID}\"]"
            fi
            ;;
        populations)
            pingone_api_get_and_print "populations${_exact_id}" "${_filter}"

            _tmp_population_id="${PINGONE_RESULT_ID}"
            if test -n "${_tmp_population_id}"; then
                printf "\n"
                pingone_api_get_and_print "users" "filter=population.id eq \"${_tmp_population_id}\""
                printf "\n"
                pingone_api_get_and_print "groups" "filter=population.id eq \"${_tmp_population_id}\""
            fi
            ;;
        *)
            usage_command
            ;;
    esac
}

################################################################################
# pingone_add
################################################################################
pingone_add() {
    USAGE_CONTEXT="USAGE_PINGONE_ADD_DETAIL"
    _resource="${1}" && shift

    #
    # Get attributes for each resource type
    #
    case "${_resource}" in
        user)
            _username="${1}" && shift
            _first_name="${1}" && shift
            _last_name="${1}" && shift
            _email="${1}"

            _name="${_username}"

            if test -z "${_email}" || test ! "${_email}" = "${_email#-}"; then
                _email="${_username}"
            else
                shift
            fi

            test -z "${_username}" && usage_command
            test -z "${_first_name}" && usage_command
            test -z "${_last_name}" && usage_command
            ;;
        group)
            _name="${1}" && shift

            get_pingone_options "${@}"
            # Remove the switches we parsed above.
            shift "$((OPTIND - 1))"

            test -z "${_name}" && usage_command
            ;;
        population)
            _name="${1}" && shift

            test -z "${_name}" && usage_command
            ;;
        *)
            usage_command
            ;;
    esac

    #
    # Get any options (including population name)
    #
    get_pingone_options "${@}"
    # Remove the switches we parsed above.
    shift "$((OPTIND - 1))"

    PINGCTL_DEFAULT_POPULATION="${PINGCTL_DEFAULT_POPULATION:-Default}"

    #
    # Create the Body Post
    #
    case "${_resource}" in
        user)
            pingone_api_get "populations" "filter=name eq \"${PINGCTL_DEFAULT_POPULATION}\""

            test -z "${PINGONE_RESULT_ID}" && echo_error "Unknown population '${PINGCTL_DEFAULT_POPULATION}'" && exit

            # jq command expects no expansion of variables. Disable shellcheck.
            # shellcheck disable=SC2016
            ${JQ} -n '{email: $email,
                  name: {given: $first,
                         family: $last},
                  population: {id: $populationId},
                  username: $username}' \
                --arg populationId "${PINGONE_RESULT_ID}" \
                --arg username "${_username}" \
                --arg email "${_email}" \
                --arg first "${_first_name}" \
                --arg last "${_last_name}" > "${PINGONE_POST_JSON}"
            ;;
        group)
            pingone_api_get "populations" "filter=name eq \"${PINGCTL_DEFAULT_POPULATION}\""

            test -z "${PINGONE_RESULT_ID}" && echo_error "Unknown population '${PINGCTL_DEFAULT_POPULATION}'" && exit

            # jq command expects no expansion of variables. Disable shellcheck.
            # shellcheck disable=SC2016
            ${JQ} -n '{name: $name,
                  population: {id: $populationId}
                 }' \
                --arg name "${_name}" \
                --arg populationId "${PINGONE_RESULT_ID}" > "${PINGONE_POST_JSON}"
            ;;
        population)
            # jq command expects no expansion of variables. Disable shellcheck.
            # shellcheck disable=SC2016
            ${JQ} -n '{name: $name}' \
                --arg name "${_name}" > "${PINGONE_POST_JSON}"
            ;;
    esac

    #
    # Finally make the POST API Call
    #
    pingone_api_post "${_resource}s"

    case "${_resource}" in
        population)
            printf "Added %s '%s'\n" "${_resource}" "${_name}"
            ;;
        *)
            printf "Added %s '%s' to population '%s'\n" "${_resource}" "${_name}" "${PINGCTL_DEFAULT_POPULATION}"
            ;;
    esac
}

################################################################################
# pingone_add_user_group
################################################################################
pingone_add_user_group() {
    _username="${1}" && shift
    _groupname="${1}" && shift

    get_pingone_options "${@}"
    # Remove the switches we parsed above.
    shift "$((OPTIND - 1))"

    test -z "${_username}" && usage_command USAGE_PINGONE_ADD_USER_GROUP_DETAIL
    test -z "${_groupname}" && usage_command USAGE_PINGONE_ADD_USER_GROUP_DETAIL

    get_pingone_options "${@}"
    # Remove the switches we parsed above.
    shift "$((OPTIND - 1))"

    pingone_api_get "users" "filter=username eq \"${_username}\""
    _user_id="${PINGONE_RESULT_ID}"

    pingone_api_get "groups" "filter=name eq \"${_groupname}\""
    _group_id="${PINGONE_RESULT_ID}"

    # jq command expects no expansion of variables. Disable shellcheck.
    # shellcheck disable=SC2016
    ${JQ} -n '{id: $groupId}' \
        --arg groupId "${_group_id}" > "${PINGONE_POST_JSON}"

    pingone_api_post "users/${_user_id}/memberOfGroups"
}

################################################################################
# pingone_delete_user_group
################################################################################
pingone_delete_user_group() {
    _username="${1}" && shift
    _groupname="${1}" && shift

    get_pingone_options "${@}"
    # Remove the switches we parsed above.
    shift "$((OPTIND - 1))"

    test -z "${_username}" && usage_command USAGE_PINGONE_DELETE_USER_GROUP_DETAIL
    test -z "${_groupname}" && usage_command USAGE_PINGONE_DELETE_USER_GROUP_DETAIL

    pingone_api_get "users" "filter=username eq \"${_username}\""
    _user_id="${PINGONE_RESULT_ID}"

    pingone_api_get "groups" "filter=name eq \"${_groupname}\""
    _group_id="${PINGONE_RESULT_ID}"

    pingone_api_delete "users/${_user_id}/memberOfGroups" "${_group_id}"
}

################################################################################
# print_jwt_token
################################################################################
print_jwt_token() {
    _token="${1}"

    get_pingone_options "${@}"
    # Remove the switches we parsed above.
    shift "$((OPTIND - 1))"

    printf "
RAW Token
---------
%s\n" "${_token}"

    ${JWT} --version 2> /dev/null > /dev/null

    if test ${?} -eq 0; then
        printf "%s" "${_token}" | ${JWT} decode -
    else
        printf "
Token details (header/claims) not available - Install jwt-cli tool for more info: brew tap mike-engel/jwt-cli; brew install jwt-cli\n"
    fi
}

################################################################################
# pingone_token
################################################################################
pingone_token() {
    _pingone_token_opt="${1}" && shift

    test -z "${_pingone_token_opt}" && usage_command USAGE_PINGONE_TOKEN_DETAIL "Missing pingone token command"

    get_pingone_options "${@}"
    # Remove the switches we parsed above.
    shift "$((OPTIND - 1))"

    case "${_pingone_token_opt}" in
        clear)
            printf "Removing %s\n" "${PINGONE_ACCESS_TOKEN_FILE}"
            rm -f "${PINGONE_ACCESS_TOKEN_FILE}"
            ;;
        info)
            if test ! -f "${PINGONE_ACCESS_TOKEN_FILE}"; then
                printf "Retrieving PingOne access_token\n"
                getPingOneAccessToken
            else
                printf "Using cached access_token [%s]\n" "${PINGONE_ACCESS_TOKEN_FILE}"
                printf "\n"
                printf "Run following to remove:\n"
                printf "   pingctl pingone token clear\n"
            fi

            if test ! -f "${PINGONE_ACCESS_TOKEN_FILE}"; then
                troubleshootPingOneSettings
                exit
            fi

            check_for_tool ${JWT}
            ${JWT} decode - < "${PINGONE_ACCESS_TOKEN_FILE}"
            ;;
        *)
            usage_command USAGE_PINGONE_TOKEN_DETAIL "Unknown pingone token command"
            ;;
    esac

}

################################################################################
# pingone_delete
################################################################################
pingone_delete() {
    USAGE_CONTEXT="USAGE_PINGONE_DELETE_DETAIL"
    _resource="${1}" && shift
    _res_name="${1}" && shift

    get_pingone_options "${@}"
    # Remove the switches we parsed above.
    shift "$((OPTIND - 1))"

    test -z "${_resource}" && usage_command
    test -z "${_res_name}" && usage_command

    case "${_resource}" in
        user)
            pingone_api_delete_by_filter "${_resource}s" "username eq \"${_res_name}\""
            ;;
        group | population)
            pingone_api_delete_by_filter "${_resource}s" "name eq \"${_res_name}\""
            ;;
        *)
            usage_command
            ;;
    esac

    printf "Deleted %s '%s'\n" "${_resource}" "${_res_name}"
}

###############################################################################
# print_rest_debug
################################################################################
print_rest_debug() {
    if test -f "${PINGONE_DEBUG}"; then
        printf "\n"
        printf "======================================\n"
        printf "PingOne REST API Info (-r option)\n"
        printf "======================================\n"
        cat "${PINGONE_DEBUG}"
    fi
}

###############################################################################
# pingone_command
################################################################################
pingone_command() {
    _pingone_command="${1}" && shift $(($# > 0 ? 1 : 0))

    case "${_pingone_command}" in
        token) #fall through to case below
            ;;
        get | add | delete | add-user-group | delete-user-group)
            getPingOneAccessToken

            if test -n "${PINGONE_ACCESS_TOKEN}"; then
                case "${_pingone_command}" in
                    get)
                        pingone_get "${@}"
                        ;;
                    add)
                        pingone_add "${@}"
                        ;;
                    delete)
                        pingone_delete "${@}"
                        ;;
                    add-user-group)
                        pingone_add_user_group "${@}"
                        ;;
                    delete-user-group)
                        pingone_delete_user_group "${@}"
                        ;;
                    *)
                        usage_command USAGE_PINGONE_DETAIL "unknown/missing pingone command: ${_pingone_command}"
                        ;;
                esac
            else
                echo_error "Unable to get a PingOne Access Token.  Options to help troubleshoot:

  pingctl pingone token info -r   # To see REST calls
  pingctl config                  # To reconfigure settings"
            fi
            ;;
        *)
            usage_command USAGE_PINGONE_DETAIL "unknown/missing pingone command: ${_pingone_command}"
            ;;
    esac

    case "${_pingone_command}" in
        token)
            pingone_token "${@}"
            ;;
        *) ;;
    esac

    print_rest_debug
}

################################################################################
# get_global_options
################################################################################
get_global_options() {
    while getopts dc OPT; do
        # shellcheck disable=SC2034
        case "$OPT" in
            c) PINGCTL_COLORIZE="on" ;;
            d) set -x ;;
            ?)
                # getopts issues an error message
                usage "Unknown Option ${OPT}"
                ;;
        esac
    done
}

################################################################################
# get_pingone_options
################################################################################
get_pingone_options() {
    while getopts hro:p:i:n:f:c:s: OPT; do
        case "$OPT" in
            h) usage_command ;;
            r) OPT_PINGONE_r=true ;;
            o) PINGCTL_DEFAULT_OUTPUT=${OPTARG} ;;
            p) PINGCTL_DEFAULT_POPULATION=${OPTARG} ;;
            i | n | f | c | s) eval "export OPT_PINGONE_\${OPT}=\"\${OPTARG}\"" ;;
            ?)
                # getopts issues an error message
                usage "Unknown Option ${OPT}"
                ;;
        esac
    done
}

################################################################################
# main
################################################################################

get_global_options "${@}"
# Remove the switches we parsed above.
shift "$((OPTIND - 1))"

_pingctl_command="${1}" && shift $(($# > 0 ? 1 : 0))

test -z "${_pingctl_command}" && usage

################################################################################
# Clear STANDARD variables and Source devops file
################################################################################
# shellcheck disable=SC2034
for _var_to_unset in ${STANDARD_VARIABLES}; do
    eval "unset \${_var_to_unset}"
done

check_config_file "${_pingctl_command}"

case "${_pingctl_command}" in
    info)
        info_command "${@}"
        ;;
    config)
        config_command
        ;;
    version)
        version_command "${@}"
        ;;
    clean)
        clean_command "${@}"
        ;;
    k8s | kubernetes)
        k8s_command "${@}"
        ;;
    lic | license)
        license_command "${@}"
        ;;
    p1 | pingone)
        pingone_command "${@}"
        ;;
    *)
        usage "unknown/missing ${CMD} command '${_pingctl_command}'"
        ;;
esac
